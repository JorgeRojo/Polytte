#include <I2Cdev.h>
#include <MPU6050_6Axis_MotionApps20.h>
#include <Arduino.h>
#include <Wire.h>
#include <driver/adc.h>

/*
Wiring
======
MPU6050    GY-521(MPU6050)
3.3V       VCC ( GY-521 has onboard regulator 5v tolerant)
GND        GND
21         SDA
22         SCL
15         INT - Note below on allowed RTC IO Pins
*/

// MPU registers
// #define SIGNAL_PATH_RESET 0x68
// #define I2C_SLV0_ADDR 0x37
// #define ACCEL_CONFIG 0x1C
// #define MOT_THR 0x1F // Motion detection threshold bits [7:0]
// #define MOT_DUR 0x20 // This seems wrong // Duration counter threshold for motion interrupt generation, 1 kHz rate, LSB = 1 ms
// #define MOT_DETECT_CTRL 0x69
// #define INT_ENABLE 0x38
// #define PWR_MGMT 0x6B //SLEEPY TIME
// #define INT_STATUS 0x3A
#define MPU6050_ADDRESS 0x68 //AD0 is 0

MPU6050 mpu(MPU6050_ADDRESS);

// MPU control/status vars
bool dmpReady = false;  // set true if DMP init was successful
uint8_t mpuIntStatus;   // holds actual interrupt status byte from MPU
uint8_t devStatus;      // return status after each device operation (0 = success, !0 = error)
uint16_t packetSize;    // expected DMP packet size (default is 42 bytes)
uint16_t fifoCount;     // count of all bytes currently in FIFO
uint8_t fifoBuffer[64]; // FIFO storage buffer

Quaternion q;        // [w, x, y, z]
VectorInt16 aa;      // [x, y, z]
VectorInt16 aaReal;  // [x, y, z]
VectorInt16 aaWorld; // [x, y, z]
VectorFloat gravity; // [x, y, z]
float ypr[3];        // [yaw, pitch, roll]

//////////////   CONFIGURATION   //////////////
//Change this 3 variables if you want to fine tune the skecth to your needs.
int buffersize = 1000; //Amount of readings used to average, make it higher to get more precision but sketch will be slower  (default:1000)
int acel_deadzone = 8; //Acelerometer error allowed, make it lower to get more precision, but sketch may not converge  (default:8)
int giro_deadzone = 1; //Giro error allowed, make it lower to get more precision, but sketch may not converge  (default:1)

int16_t ax, ay, az, gx, gy, gz;
int mean_ax, mean_ay, mean_az, mean_gx, mean_gy, mean_gz;
int ax_offset, ay_offset, az_offset, gx_offset, gy_offset, gz_offset = 0;

int mpuState = 0;

void writeByte(uint8_t address, uint8_t subAddress, uint8_t data)
{
    
    Wire.begin();
    Wire.beginTransmission(address); // Initialize the Tx buffer
    Wire.write(subAddress);          // Put slave register address in Tx buffer
    Wire.write(data);                // Put data in Tx buffer
    Wire.endTransmission();          // Send the Tx buffer
}

uint8_t readByte(uint8_t address, uint8_t subAddress)
{
    uint8_t data;                          // `data` will store the register data
    Wire.beginTransmission(address);       // Initialize the Tx buffer
    Wire.write(subAddress);                // Put slave register address in Tx buffer
    Wire.endTransmission(false);           // Send the Tx buffer, but send a restart to keep connection alive
    Wire.requestFrom(address, (uint8_t)1); // Read one byte from slave register address
    data = Wire.read();                    // Fill Rx buffer with result
    return data;                           // Return data read from slave register
}

void mpuConfiguration(int sens)
{ 
    writeByte(MPU6050_ADDRESS, 0x6B, 0x00);
    writeByte(MPU6050_ADDRESS, SIGNAL_PATH_RESET, 0x07); //Reset all internal signal paths in the MPU-6050 by writing 0x07 to register 0x68;
    writeByte( MPU6050_ADDRESS, I2C_SLV0_ADDR, 0x20);//write register 0x37 to select how to use the interrupt pin. For an active high, push-pull signal that stays until register (decimal) 58 is read, write 0x20.
    writeByte(MPU6050_ADDRESS, ACCEL_CONFIG, 0x01);    //Write register 28 (==0x1C) to set the Digital High Pass Filter, bits 3:0. For example set it to 0x01 for 5Hz. (These 3 bits are grey in the data sheet, but they are used! Leaving them 0 means the filter always outputs 0.)
    writeByte(MPU6050_ADDRESS, MOT_THR, sens);         //Write the desired Motion threshold to register 0x1F (For example, write decimal 20).
    writeByte(MPU6050_ADDRESS, MOT_DUR, 40);           //Set motion detect duration to 1  ms; LSB is 1 ms @ 1 kHz rate
    writeByte(MPU6050_ADDRESS, MOT_DETECT_CTRL, 0x15); //to register 0x69, write the motion detection decrement and a few other settings (for example write 0x15 to set both free-fall and motion decrements to 1 and accelerometer start-up delay to 5ms total by adding 1ms. )
    writeByte(MPU6050_ADDRESS, 0x37, 140);             // now INT pin is active low
    writeByte(MPU6050_ADDRESS, INT_ENABLE, 0x40);      //write register 0x38, bit 6 (0x40), to enable motion detection interrupt.
    writeByte(MPU6050_ADDRESS, PWR_MGMT, 8);           // 101000 - Cycle & disable TEMP SENSOR
    writeByte(MPU6050_ADDRESS, 0x6C, 7);               // Disable Gyros
}

void mpuInitialize()
{
    // initialize device
    mpu.initialize();

    // connection test
    Serial.println(F("MPU -> Testing device connections..."));
    if (mpu.testConnection()) {
        Serial.println(F("MPU -> Connection successful"));
    }
    else {
        Serial.println(F("MPU -> Connection failed"));
    }

    // initialice DMP
    Serial.println(F("MPU -> Initializing DMP..."));
    devStatus = mpu.dmpInitialize();

    // reset offsets
    mpu.setXAccelOffset(0);
    mpu.setYAccelOffset(0);
    mpu.setZAccelOffset(0);
    mpu.setXGyroOffset(0);
    mpu.setYGyroOffset(0);
    mpu.setZGyroOffset(0);

    // Enabling DMP
    if (devStatus == 0)
    {
        Serial.println(F("MPU -> Enabling DMP..."));
        mpu.setDMPEnabled(true); 
        mpuIntStatus = mpu.getIntStatus(); 
        dmpReady = true; 
        packetSize = mpu.dmpGetFIFOPacketSize();
    }
    else
    { 
        Serial.print(F("MPU -> DMP Initialization failed (code "));
        Serial.print(devStatus);
        Serial.println(F(")"));
    }

}

void mpuMeansensors()
{
    long i = 0, buff_ax = 0, buff_ay = 0, buff_az = 0, buff_gx = 0, buff_gy = 0, buff_gz = 0;

    while (i < (buffersize + 101))
    {
        // read raw accel/gyro measurements from device
        mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

        if (i > 100 && i <= (buffersize + 100))
        { //First 100 measures are discarded
            buff_ax = buff_ax + ax;
            buff_ay = buff_ay + ay;
            buff_az = buff_az + az;
            buff_gx = buff_gx + gx;
            buff_gy = buff_gy + gy;
            buff_gz = buff_gz + gz;
        }
        if (i == (buffersize + 100))
        {
            mean_ax = buff_ax / buffersize;
            mean_ay = buff_ay / buffersize;
            mean_az = buff_az / buffersize;
            mean_gx = buff_gx / buffersize;
            mean_gy = buff_gy / buffersize;
            mean_gz = buff_gz / buffersize;
        }
        i++;

        delay(1); //Needed so we don't get repeated measures
    }
}

void mpuCalibration()
{
    ax_offset = -mean_ax / 8;
    ay_offset = -mean_ay / 8;
    az_offset = (16384 - mean_az) / 8;

    gx_offset = -mean_gx / 4;
    gy_offset = -mean_gy / 4;
    gz_offset = -mean_gz / 4;
    while (1)
    {
        int ready = 0;
        mpu.setXAccelOffset(ax_offset);
        mpu.setYAccelOffset(ay_offset);
        mpu.setZAccelOffset(az_offset);

        mpu.setXGyroOffset(gx_offset);
        mpu.setYGyroOffset(gy_offset);
        mpu.setZGyroOffset(gz_offset);

        mpuMeansensors();
        Serial.println("...");

        if (abs(mean_ax) <= acel_deadzone)
            ready++;
        else
            ax_offset = ax_offset - mean_ax / acel_deadzone;

        if (abs(mean_ay) <= acel_deadzone)
            ready++;
        else
            ay_offset = ay_offset - mean_ay / acel_deadzone;

        if (abs(16384 - mean_az) <= acel_deadzone)
            ready++;
        else
            az_offset = az_offset + (16384 - mean_az) / acel_deadzone;

        if (abs(mean_gx) <= giro_deadzone)
            ready++;
        else
            gx_offset = gx_offset - mean_gx / (giro_deadzone + 1);

        if (abs(mean_gy) <= giro_deadzone)
            ready++;
        else
            gy_offset = gy_offset - mean_gy / (giro_deadzone + 1);

        if (abs(mean_gz) <= giro_deadzone)
            ready++;
        else
            gz_offset = gz_offset - mean_gz / (giro_deadzone + 1);

        if (ready == 6)
            break;
    }
}

void _mpu_state_0()
{
    if (mpuState != 0) return;  
    Serial.println("MPU -> Reading sensors...");
    mpuMeansensors();
    mpuState++;
    delay(500);
}
void _mpu_state_1()
{
    if (mpuState != 1) return; 
    Serial.println("MPU -> Calculating offsets...");
    mpuCalibration();
    mpuState++;
    delay(500);
}
void _mpu_state_2()
{
    if (mpuState != 2) return; 
    mpuMeansensors(); 

    Serial.print("MPU -> Sensor readings with offsets:\t");
    Serial.print(mean_ax); Serial.print("\t");
    Serial.print(mean_ay); Serial.print("\t");
    Serial.print(mean_az); Serial.print("\t");
    Serial.print(mean_gx); Serial.print("\t");
    Serial.print(mean_gy); Serial.print("\t");
    Serial.println(mean_gz);

    Serial.print("MPU -> Your offsets:\t");
    Serial.print(ax_offset); Serial.print("\t");
    Serial.print(ay_offset); Serial.print("\t");
    Serial.print(az_offset); Serial.print("\t");
    Serial.print(gx_offset); Serial.print("\t");
    Serial.print(gy_offset); Serial.print("\t");
    Serial.println(gz_offset);

    Serial.println("MPU -> Data is printed as: acelX acelY acelZ giroX giroY giroZ");

    mpu.setXAccelOffset(ax_offset);
    mpu.setYAccelOffset(ay_offset);
    mpu.setZAccelOffset(az_offset);
    mpu.setXGyroOffset(gx_offset);
    mpu.setYGyroOffset(gy_offset);
    mpu.setZGyroOffset(gz_offset);

    mpuState++; 
    delay(500);
}
void _mpu_state_3()
{
    if (mpuState != 3) return;  
    Serial.print("MPU -> TODO: save calibration in storage \t");
    mpuState++;
    delay(500);
}
void _mpu_state_4()
{
    if (mpuState != 4) return;
 

    mpuIntStatus = mpu.getIntStatus();
    delay(10);
    fifoCount = mpu.getFIFOCount();

    // Serial.print("MPU -> mpuIntStatus \t");
    // Serial.println(mpuIntStatus & 0x10);
    // Serial.print("MPU -> fifoCount \t");
    // Serial.println(fifoCount);

    // Control overflow
    if ((mpuIntStatus & 0x10) || fifoCount == 1024) {
        mpu.resetFIFO(); 
        Serial.println("MPU -> Reset FIFO \t");
    }
    else if (mpuIntStatus & 0x02) {

        while (fifoCount < packetSize) {
            fifoCount = mpu.getFIFOCount();
        }  

        mpu.getFIFOBytes(fifoBuffer, packetSize); 
        fifoCount -= packetSize;


        //Yaw, Pitch, Roll
        mpu.dmpGetQuaternion(&q, fifoBuffer);
        mpu.dmpGetGravity(&gravity, &q);
        mpu.dmpGetYawPitchRoll(ypr, &q, &gravity);
        Serial.print("YPR\t");
        Serial.print(ypr[0] * 180 / M_PI); Serial.print("\t");
        Serial.print(ypr[1] * 180 / M_PI); Serial.print("\t");
        Serial.print(ypr[2] * 180 / M_PI); Serial.println();
 
        //Acceleration
        // mpu.dmpGetQuaternion(&q, fifoBuffer);
        // mpu.dmpGetAccel(&aa, fifoBuffer);
        // mpu.dmpGetGravity(&gravity, &q);
        // mpu.dmpGetLinearAccel(&aaReal, &aa, &gravity);
        // Serial.println("\tAREAL\t");
        // Serial.print(aaReal.x); Serial.print("\t");
        // Serial.print(aaReal.y); Serial.print("\t");
        // Serial.print(aaReal.z); Serial.println();

    }
    delay(500);

}

void sendNotification(String message)
{
    Serial.println(message);
}

void setup()
{
    int start = esp_timer_get_time();
    Serial.begin(115200);

    sendNotification("Motion Detected");
    mpuConfiguration(1); // Setup MPU for interrupt, power down gyros & temp sensor
    mpuInitialize();

 
    
    // int end = esp_timer_get_time();
    // int total = end - start;
    // Serial.println(total);
    // Serial.println("Sleeping");
    // adc_power_off(); // adc power off disables wifi entirely, upstream bug
    // esp_sleep_enable_ext0_wakeup(GPIO_NUM_15, 0);
    // delay(500); //1 = High, 0 = Low
    // adc_power_off();
    // esp_deep_sleep_start();
}

void loop()
{   
    
    if(dmpReady) {
        _mpu_state_0();
        _mpu_state_1();
        _mpu_state_2();
        _mpu_state_3();
        _mpu_state_4();
    }
    delay(500);
}